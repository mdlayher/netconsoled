// Command netconsoled provides a server that can receive and process logs
// generated by the netconsole Linux kernel module.
package main

import (
	"context"
	"flag"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/mdlayher/netconsole"
	"github.com/mdlayher/netconsoled"
	"github.com/mdlayher/netconsoled/internal/config"
)

func main() {
	const defaultConfig = "netconsoled.yml"

	var (
		config = flag.String("c", defaultConfig, "location of netconsoled's configuration file")
		init   = flag.Bool("init", false, "create a new configuration file")
	)

	flag.Parse()
	ll := log.New(os.Stderr, "", log.Ldate|log.Ltime)

	if *init {
		initConfig(ll, defaultConfig)
		return
	}

	run(ll, *config)
}

func initConfig(ll *log.Logger, file string) {
	ll.Printf("creating netconsoled configuration file %q", file)

	const defaultYAML = `---
# Configuration of the netconsoled server.
server:
  # Required: listen for incoming netconsole logs.
  udp_addr: :6666
  # Optional: enable HTTP server for additional functionality.
  http_addr: :8080
# Zero or more filters to apply to incoming logs.
filters:
  - type: noop
# Zero or more sinks to use to store processed logs.
sinks:
  - type: noop
`

	if err := ioutil.WriteFile(file, []byte(defaultYAML), 0644); err != nil {
		ll.Fatalf("failed to write default configuration file %q: %v", file, err)
	}
}

func run(ll *log.Logger, file string) {
	ll.Printf("starting netconsoled with configuration file %q", file)

	b, err := ioutil.ReadFile(file)
	if err != nil {
		ll.Fatalf("failed to read configuration file: %v", err)
	}

	cfg, err := config.Parse(b)
	if err != nil {
		ll.Fatalf("failed to process configuration file: %v", err)
	}

	ll.Printf("loaded %d filter(s):", len(cfg.Filters))
	for _, f := range cfg.Filters {
		ll.Printf("  - %s", f.String())
	}

	ll.Printf("loaded %d sink(s):", len(cfg.Sinks))
	for _, s := range cfg.Sinks {
		ll.Printf("  - %s", s.String())
	}

	s := &netconsoled.Server{
		Filter:   netconsoled.MultiFilter(cfg.Filters...),
		Sink:     netconsoled.MultiSink(cfg.Sinks...),
		ErrorLog: ll,
	}

	// Start each network service in its own goroutine so they can
	// be shut down at a later time.

	go func() {
		ns := netconsole.NewServer("udp", cfg.Server.UDPAddr, s.Handle)

		ll.Printf("starting UDP server at %q", cfg.Server.UDPAddr)

		if err := ns.ListenAndServe(context.Background()); err != nil {
			ll.Fatalf("failed to listen UDP: %v", err)
		}
	}()

	go func() {
		hs := &http.Server{
			Addr:     cfg.Server.HTTPAddr,
			Handler:  s,
			ErrorLog: ll,
		}

		ll.Printf("starting HTTP server at %q", cfg.Server.HTTPAddr)

		if err := hs.ListenAndServe(); err != nil {
			ll.Fatalf("failed to listen HTTP: %v", err)
		}
	}()

	// Block main goroutine forever.
	// TODO(mdlayher): consider graceful shutdown to flush sinks.
	select {}
}
